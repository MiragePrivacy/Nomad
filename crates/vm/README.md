# Nomad VM Specification

## Overview

The Nomad VM is a simple virtual machine designed for executing signal puzzles.
It provides a controlled execution environment with fixed memory and register constraints.

## Architecture

### Memory Model

- **Memory Size**: 1 GiB (1,073,741,824 bytes)
- **Registers**: 8 x 32-bit registers (R0-R7)
- **Word Size**: 32 bits
- **Endianness**: Big-endian for multi-byte values

### Execution Model

- **Program Counter**: Tracks current instruction index
- **Cycle Limit**: Configurable maximum cycles per execution
- **Output**: 256-bit result concatenated from registers (R0-R7)

## Instruction Set Architecture (ISA)

### Instruction Format

All instructions follow a variable-length encoding with opcode-specific layouts:

| Instruction | Opcode | Size | Format |
|-------------|--------|------|--------|
| SET         | 0x00   | 6    | `opcode(1) + reg(1) + value(4)` |
| LOAD        | 0x01   | 6    | `opcode(1) + reg(1) + addr(4)` |
| STORE       | 0x02   | 6    | `opcode(1) + reg(1) + addr(4)` |
| ADD         | 0x03   | 4    | `opcode(1) + dst(1) + src1(1) + src2(1)` |
| SUB         | 0x04   | 4    | `opcode(1) + dst(1) + src1(1) + src2(1)` |
| XOR         | 0x05   | 4    | `opcode(1) + dst(1) + src1(1) + src2(1)` |
| JMP         | 0x06   | 5    | `opcode(1) + target(4)` |
| JMPEQ       | 0x07   | 7    | `opcode(1) + reg1(1) + reg2(1) + target(4)` |
| JMPNE       | 0x08   | 7    | `opcode(1) + reg1(1) + reg2(1) + target(4)` |
| HALT        | 0xFF   | 1    | `opcode(1)` |

### Instruction Set

#### Data Movement Instructions

**SET reg, value**
- Sets register `reg` to immediate `value`
- Example: `SET R0, 42` sets register 0 to 42

**LOAD reg, addr**
- Loads 32-bit value from memory address `addr` into register `reg`
- Example: `LOAD R1, 0x1000` loads 4 bytes from address 0x1000 into R1

**STORE reg, addr**
- Stores register `reg` value to memory address `addr`
- Example: `STORE R2, 0x2000` stores R2 value to address 0x2000

#### Arithmetic Instructions

**ADD dst, src1, src2**
- Performs `dst = src1 + src2` with wrapping overflow
- Example: `ADD R0, R1, R2` sets R0 to R1 + R2

**SUB dst, src1, src2**
- Performs `dst = src1 - src2` with wrapping underflow
- Example: `SUB R0, R1, R2` sets R0 to R1 - R2

**XOR dst, src1, src2**
- Performs bitwise XOR `dst = src1 ^ src2`
- Example: `XOR R0, R1, R2` sets R0 to R1 XOR R2

#### Control Flow Instructions

**JMP target**
- Unconditional jump to instruction index `target`
- Example: `JMP 10` jumps to instruction 10

**JMPEQ reg1, reg2, target**
- Conditional jump to `target` if `reg1 == reg2`
- Example: `JMPEQ R0, R1, 5` jumps to instruction 5 if R0 equals R1

**JMPNE reg1, reg2, target**
- Conditional jump to `target` if `reg1 != reg2`
- Example: `JMPNE R0, R1, 5` jumps to instruction 5 if R0 not equal to R1

**HALT**
- Stops program execution and returns register state
- No operands required

## Execution Semantics

### Program Loading

1. Bytecode is parsed into instruction sequence
2. Instructions are validated for proper formatting
3. Register and memory addresses are bounds-checked

### Execution Loop

1. Fetch instruction at program counter
2. Decode and validate instruction
3. Execute instruction
4. Increment cycle counter
5. Check for halt condition or cycle limit
6. Repeat until termination

### Termination Conditions

- `HALT` instruction executed
- Maximum cycle count exceeded
- Program counter out of bounds
- Runtime error (invalid memory access, etc.)

### Result Generation

Upon termination, the 256-bit result is generated by concatenating all 8 registers in big-endian format:
```
result[0..4]   = R0.to_be_bytes()
result[4..8]   = R1.to_be_bytes()
result[8..12]  = R2.to_be_bytes()
result[12..16] = R3.to_be_bytes()
result[16..20] = R4.to_be_bytes()
result[20..24] = R5.to_be_bytes()
result[24..28] = R6.to_be_bytes()
result[28..32] = R7.to_be_bytes()
```

## Security Considerations

- Fixed memory bounds prevent buffer overflows
- Cycle limits prevent infinite loops
- Register validation ensures memory safety
- No system calls or external access
- Deterministic execution for reproducible results
